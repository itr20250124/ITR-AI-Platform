import { OpenAIImageService } from '../OpenAIImageService';
import OpenAI from 'openai';

// Mock OpenAI
jest.mock('openai');
const MockedOpenAI = OpenAI as jest.MockedClass<typeof OpenAI>;

describe('OpenAIImageService', () => {
  let service: OpenAIImageService;
  let mockOpenAI: jest.Mocked<OpenAI>;

  beforeEach(() => {
    // Set up environment variable
    process.env.OPENAI_API_KEY = 'test-api-key';
    
    // Create mock OpenAI instance
    mockOpenAI = {
      images: {
        generate: jest.fn(),
        createVariation: jest.fn(),
        edit: jest.fn(),
      },
    } as any;

    MockedOpenAI.mockImplementation(() => mockOpenAI);
    
    service = new OpenAIImageService();
  });

  afterEach(() => {
    jest.clearAllMocks();
    delete process.env.OPENAI_API_KEY;
  });

  describe('generateImage', () => {
    it('should generate image with DALL-E 3', async () => {
      const mockResponse = {
        data: [
          {
            url: 'https://example.com/image.png',
            revised_prompt: 'A beautiful sunset over mountains',
          },
        ],
      };

      mockOpenAI.images.generate.mockResolvedValue(mockResponse as any);

      const result = await service.generateImage('A sunset', {
        model: 'dall-e-3',
        size: '1024x1024',
        quality: 'hd',
        style: 'vivid',
      });

      expect(result).toMatchObject({
        imageUrl: 'https://example.com/image.png',
        prompt: 'A sunset',
        status: 'completed',
        metadata: {
          model: 'dall-e-3',
          revisedPrompt: 'A beautiful sunset over mountains',
        },
      });

      expect(mockOpenAI.images.generate).toHaveBeenCalledWith({
        model: 'dall-e-3',
        prompt: 'A sunset',
        n: 1,
        size: '1024x1024',
        response_format: 'url',
        quality: 'hd',
        style: 'vivid',
      });
    });

    it('should generate image with DALL-E 2', async () => {
      const mockResponse = {
        data: [
          {
            url: 'https://example.com/image.png',
          },
        ],
      };

      mockOpenAI.images.generate.mockResolvedValue(mockResponse as any);

      const result = await service.generateImage('A cat', {
        model: 'dall-e-2',
        size: '512x512',
        n: 2,
      });

      expect(result.imageUrl).toBe('https://example.com/image.png');
      expect(mockOpenAI.images.generate).toHaveBeenCalledWith({
        model: 'dall-e-2',
        prompt: 'A cat',
        n: 2,
        size: '512x512',
        response_format: 'url',
      });
    });

    it('should throw error when no image data returned', async () => {
      mockOpenAI.images.generate.mockResolvedValue({
        data: [],
      } as any);

      await expect(
        service.generateImage('A sunset')
      ).rejects.toThrow('No image data returned from OpenAI');
    });

    it('should throw error when image URL is missing', async () => {
      mockOpenAI.images.generate.mockResolvedValue({
        data: [{}],
      } as any);

      await expect(
        service.generateImage('A sunset')
      ).rejects.toThrow('No image generated by OpenAI');
    });
  });

  describe('parameter validation', () => {
    it('should validate DALL-E 2 size restrictions', async () => {
      await expect(
        service.generateImage('A sunset', {
          model: 'dall-e-2',
          size: '1792x1024',
        })
      ).rejects.toThrow('DALL-E 2 only supports 256x256, 512x512, or 1024x1024 sizes');
    });

    it('should validate DALL-E 3 n parameter restriction', async () => {
      await expect(
        service.generateImage('A sunset', {
          model: 'dall-e-3',
          n: 2,
        })
      ).rejects.toThrow('DALL-E 3 only supports generating 1 image at a time');
    });

    it('should validate DALL-E 2 quality parameter', async () => {
      await expect(
        service.generateImage('A sunset', {
          model: 'dall-e-2',
          quality: 'hd',
        })
      ).rejects.toThrow('DALL-E 2 only supports standard quality');
    });

    it('should validate DALL-E 2 style parameter', async () => {
      await expect(
        service.generateImage('A sunset', {
          model: 'dall-e-2',
          style: 'natural',
        })
      ).rejects.toThrow('DALL-E 2 does not support style parameter');
    });

    it('should validate DALL-E 3 size restrictions', async () => {
      await expect(
        service.generateImage('A sunset', {
          model: 'dall-e-3',
          size: '512x512',
        })
      ).rejects.toThrow('DALL-E 3 only supports 1024x1024, 1792x1024, or 1024x1792 sizes');
    });
  });

  describe('createVariation', () => {
    it('should create image variation', async () => {
      const mockResponse = {
        data: [
          {
            url: 'https://example.com/variation.png',
          },
        ],
      };

      mockOpenAI.images.createVariation.mockResolvedValue(mockResponse as any);

      const mockFile = new File([''], 'test.png', { type: 'image/png' });
      const result = await service.createVariation(mockFile, {
        n: 1,
        size: '1024x1024',
      });

      expect(result.imageUrl).toBe('https://example.com/variation.png');
      expect(result.metadata?.type).toBe('variation');
    });
  });

  describe('editImage', () => {
    it('should edit image', async () => {
      const mockResponse = {
        data: [
          {
            url: 'https://example.com/edited.png',
          },
        ],
      };

      mockOpenAI.images.edit.mockResolvedValue(mockResponse as any);

      const mockImageFile = new File([''], 'image.png', { type: 'image/png' });
      const mockMaskFile = new File([''], 'mask.png', { type: 'image/png' });
      
      const result = await service.editImage(
        mockImageFile,
        mockMaskFile,
        'Add a rainbow',
        { n: 1, size: '1024x1024' }
      );

      expect(result.imageUrl).toBe('https://example.com/edited.png');
      expect(result.metadata?.type).toBe('edit');
    });
  });

  describe('error handling', () => {
    it('should handle API errors', async () => {
      const apiError = new Error('API Error');
      mockOpenAI.images.generate.mockRejectedValue(apiError);

      await expect(service.generateImage('A sunset')).rejects.toThrow();
    });
  });
});